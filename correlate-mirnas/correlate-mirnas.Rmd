## correlate-mirnas
_Last modified `r format(Sys.time(), "%I:%M %p on %b %d, %Y")`. This document, R session image, knitr cache, figures, and other associated datasets are located in `cruncher:/inside/grotto/blin/trna-markers/correlate-mirnas/`._

```{r setup, echo=FALSE, warning=FALSE, results=FALSE, message=FALSE, errors=FALSE, cache=FALSE}
library(knitr)
opts_chunk$set(cache=TRUE, cache.path="/inside/grotto/blin/trna-markers/correlate-mirnas/cache/", eval=TRUE, echo=TRUE, warning=FALSE, results=FALSE, message=FALSE, autodep=TRUE, dev="png", dpi=300)
```

```{r libraries, cache=FALSE}
library(DESeq2)
library(BiocParallel)
library(reshape2)
library(ggplot2)
library(stringr)
register(MulticoreParam(8)) # turn this off depending on your machine!
load('/inside/grotto/blin/trna-markers/feature-counts/feature-counts.RData')
```

The correlation will be performed on a matrix of fold changes. I'm not sure whether I should take the log<sub>2</sub> fold change before then. I do in this case, to minimize heteroscedasticity - reduce the variability between sub-populations, which in this case is individual genes or groups of genes. Since these are `log2` values, and there are fragments with counts of 0, we will use Laplacian smoothing (add a pseudocount of 1) to avoid `-Inf` values.

```{r fold-change}
# NT normalized counts - TP normalized counts
getFoldChanges <- function(metadata, counts) {
	# first, get counts for matched samples
	nt_matched_samples <- metadata[which(metadata$paired == TRUE && metadata$sample_type == "NT")]$barcode
	tp_matched_samples <- metadata[which(metadata$paired == TRUE && metadata$sample_type == "TP")]$barcode
	fold_changes <- counts[nt_matched_samples, ] - counts[tp_matched_samples, ]
	# second, get counts for unmatched samples (no extra normal tissue samples, only extra primary tumor samples)
	nt_samples <- metadata[which(metadata$sample_type == "NT"), ]$barcode # get normal tumor sample barcodes
	nt_median <- apply(counts[nt_samples, ], 1, median) # get median counts for each feature
	cbind(fold_changes, nt_median - counts[-nt_samples, ]) # subtract tumor counts from median nt counts to get the fold change
}
# TODO: add column (sample) names to fold changes object
fold_changes <- getFoldChanges(prad_metadata, counts)
```

I also have to choose between Pearson's r and Spearman's $\rho$. Apparently, Pearson's r has more power and finds linear (as opposed to monotonic) relationships, so I'll start with that.

```{r pearson}
correlations <- cor(t(fold_changes), method = "pearson") # function operates on columns, so need to get features onto columns.
```

```{r mir-correlations}
mir_corr <- correlations[!str_detect(colnames(correlations), "hsa"), str_detect(colnames(correlations), "hsa")] # isolate for miRNAs
mir_corr_df <- melt(mir_corr)
colnames(mir_corr_df) <- c("Feature", "miRNA", "r")
mir_corr_df <- mir_corr_df[order(mir_corr_df$r, decreasing = TRUE), ]
#mirnas <- colnames(mir_corr)
#mir_corr <- lapply(1:ncol(mir_corr), function(mirna_column) mir_corr[, mirna_column][order(mir_corr[, mirna_column], decreasing = TRUE)]) # sort correlation matrix. This line is convoluted because *apply removes row names upon return, and we need to preserve the row names (feature identifiers).
#names(mir_corr) <- mirnas
```

```{r show-correlations}
# sample 5 elements, then sample 5 rows with those elements
plot_data <- mir_corr_df[which(mir_corr_df$Feature %in% sample(mir_corr_df$Feature, 5) & (mir_corr_df$r >= 0.25 | mir_corr_df$r <= -0.25)), ]
#plot <- qplot(x = plot_data$Feature, y = plot_data$r, data = plot_data, geom = "point")
plot <- qplot(data = plot_data, x = plot_data$Feature, y = plot_data$r, geom = "point") + theme(axis.text.x = element_text(angle = -45, hjust = 0))
#plot <- ggplot() + geom_point(data = plot_data, aes(x = Feature, y = r)) + theme(axis.text.x = element_text(angle = -45, hjust = 0))#+ geom_line(data = plot_data, aes(x = Feature, y = r)) + geom_text(data = plot_data, aes(x = Feature, y = r, label = miRNA, hjust = 0.2, vjust = 0.2)) + 
plot
interactive_plot <- plotly()$ggplotly(plot)
```

<iframe src="`r interactive_plot$response$url`" width="750" height="600"></iframe>

For this analysis, these are the most strongest negative and positive correlations with mir-hsa-31.


### Selecting key miRNAs
#### Differentially expressed miRNAs identified by Schaefer et al. (2009)
Originally, I used the miRNAs derived from [this paper](http://dx.doi.org/10.1002/ijc.24827), which describes miRNAs dysregulated in prostate carcinoma. This list of miRNAs can be found at `/inside/grotto/blin/trna-markers/feature-counts/prad-mirnas-1.bed`. Four of these are upregulated, and the other five are downregulated.

The problem with this set of miRNAs is that only `hsa-mir-31` survives the purge.

#### Broad GDAC Firehose PRAD T stage miRNAs
Later analyses showed that most of these miRNAs weren't expressed at a high enough level to be correlated with anything at all. Yikes. I'm going to try using [Broad Firehose](http://gdac.broadinstitute.org/runs/analyses__latest/reports/cancer/PRAD/Correlate_Clinical_vs_miRseq/nozzle.html) instead. There are 16 miRNAs negatively correlated with T stage. I don't know what "negatively correlated with lower stage" means in this context - will need to ask someone from Josh's lab to see what's going on. 

Actually, there aren't 16 miRNAs. The very first one, [hsa-mir-3676](http://www.mirbase.org/cgi-bin/mirna_entry.pl?acc=MI0016077), is actually a tRF! I'll look into this later. There are 32 sequences associated from the remaining 15 miRNAs - mostly due to 5' and 3' miRNA fragments from the precursor sequence, but also due to +/- strand entries. These sequences are located at `/inside/grotto/blin/trna-markers/feature-counts/prad-mirnas-2.gff`.


### Cluster

We can also cluster the features by their fold changes in the 52 samples.

```{r clusters}

```

```{r save-image, echo=FALSE, cache=FALSE}
save.image('correlate-mirnas-image.RData')
```


