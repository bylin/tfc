# Count features in TCGA PRAD small RNA sequencing data
_Last modified `r format(Sys.time(), "%I:%M %p on %b %d, %Y")`. This document, R session image, knitr cache, figures, and other associated datasets are located in `cruncher:/inside/grotto/blin/trna-markers/feature-counts/`._

```{r setup, echo=FALSE, warning=FALSE, results=FALSE, message=FALSE, errors=FALSE, cache=FALSE}
library(knitr)
opts_chunk$set(cache=TRUE, cache.path="/inside/grotto/blin/trna-markers/feature-counts/cache/", eval=TRUE, echo=TRUE, warning=FALSE, results=FALSE, message=FALSE, autodep=TRUE, dev="png", dpi=300)
```

```{r libraries, cache=FALSE}
library(GenomicRanges)
library(GenomicAlignments)
library(Biobase)
library(stringr)
source('/inside/grotto/blin/programs/convertChrNames.R')
attach('/inside/grotto/blin/trna-markers/process-reads/process-reads-image.RData')
```

## Building a features list

### RNase Z dependent terminal tRNA fragments

Recently, [tRFdb](http://genome.bioch.virginia.edu/trfdb/) was released, with 552 human tRNA fragments. These were downloaded into `/inside/grotto/blin/data/tRFdb-human.tab`, and processed into a better file format, `tRFdb-human.gtf`. I can read this in and convert to a `GRanges` object.

```{r features-fragments}
frags <- read.delim('tRFdb-human.gtf', comment.char = "#", header = FALSE, col.names = c("seqid", "source", "type", "start", "end", "score", "strand", "phase", "attributes"))
frags$strand <- ifelse(frags$start - frags$end < 0, "+", "-")
frags[frags$strand == "-", c("start", "end")] <- frags[frags$strand == "-", c("end", "start")]
frags <- GRanges(seqnames = frags$seqid, ranges = IRanges(frags$start, frags$end), strand = ifelse(frags$start - frags$end < 0, "+", "-"), tx_name = paste0(str_extract(frags$attributes, "(chr.+trna\\d+-\\w+)"), "-", str_extract(frags$attributes, "\\d\\d\\d\\d\\w?")))
mcols(frags)$class <- "tRF1"
mcols(frags[str_detect(mcols(frags)$tx_name, "-3")])$class <- "tRF3"
mcols(frags[str_detect(mcols(frags)$tx_name, "-5")])$class <- "tRF5"
frags <- convertChrNames(frags, "Ensembl")
```

### Angiogenin dependent tRNA halves

Andrew has generated a feature list (available at `/inside/grotto/blin/trna-markers/feature-counts/hg19-trnahalfs.gtf`), so we'll use that for now. It's stored as a `.gtf` file, so it follows a similar process as above. Currently, there is an issue with Andrew's covariance model that results in reversed 5' tRFs, with end = start - 1. For the time being, those features have been deleted from the list. This list 

```{r features-halves}
halves <- read.delim('hg19-trnahalves.gtf', header = FALSE, col.names = c("seqid", "source", "type", "start", "end", "score", "strand", "phase", "attributes"))
halves <- GRanges(seqnames = halves$seqid, ranges = IRanges(halves$start, halves$end), strand = halves$strand, tx_name = str_extract(halves$attributes, "(tRNA|chr\\w+\\.\\w+|nmt)(-\\w+\\?*)+_(threehalf|fivehalf|trailer)"))
mcols(halves)$class <- "trailer"
mcols(halves[str_detect(mcols(halves)$tx_name, "threehalf")])$class <- "3half"
mcols(halves[str_detect(mcols(halves)$tx_name, "fivehalf")])$class <- "5half"
halves <- convertChrNames(halves, "Ensembl")
```

I had what Aaron called an "A-list" of miRNAs involved in prostate cancer. These are now documented in [correlate-mirnas](correlate-mirnas.html). I am now following suggestions to just throw the entire human miRNA pool in and extracting what we need later.

Combining the miRNAs with the tRFs is simple with `GRanges`. We just need to read them in first. The miRNAs are formatted as a bed file. In the interest of having a more complete set of data, I am using the entire miRNA primary transcript instead of miRNA levels.

```{r features-mirnas}
mirnas <- read.delim('/inside/grotto/blin/data/mir-hsa-primary.gff3', header = FALSE, stringsAsFactors = FALSE, col.names = c("seqid", "source", "type", "start", "end", "score", "strand", "phase", "attributes"))
mirnas <- GRanges(seqnames = mirnas$seqid, ranges = IRanges(start = mirnas$start, end = mirnas$end), strand = mirnas$strand, tx_name = str_extract(mirnas$attributes, "hsa(-\\w+)+"))
mirnas <- convertChrNames(mirnas, "Ensembl")
mcols(mirnas)$class <- "miRNA"
features <- c(frags, halves, mirnas)
```

Reads for TCGA miRNA tend to be between 20-30 bp. If the overlap between a locus and a pair of reads is greater than or equal to 5 bp, we consider it one transcript spanning the feature. The following function is similar to the above, and returns a matrix with rows as features and columns as the sample. We don't need to divide the counts by feature length because miRNA sequencing is typically not fragmented prior to sequencing. 

```{r count-function}
countFeaturesFromBam <- function(bamfiles, features, dir = ".") {
  bamfiles <- paste0(dir, "/", bamfiles)
  counts <- vector()
  # use a for loop because r will run out of memory
  for (bamfile in bamfiles) {
  	sample <- readGAlignments(bamfile)
  	counts <- cbind(counts, countOverlaps(features, sample, minoverlap = 5))
  }
  counts
}
```

```{r count-features}
feature_counts <- countFeaturesFromBam(prad_metadata$shortnames, features, '/inside/grotto/blin/trna-markers/mirna/prad')
```

```{r convert-ExpressionSet}
rownames(feature_counts) <- mcols(features)$tx_name
colnames(feature_counts) <- prad_metadata$barcode
feature_counts <- as.data.frame(feature_counts)
pheno_data <- AnnotatedDataFrame(data.frame(row.names = prad_metadata$barcode, sample_type = prad_metadata$sample_type))
tRF_expression <- ExpressionSet(assayData = as.matrix(feature_counts), pheno_data = pheno_data) 
```

This formats data a way that we can reference in later steps. We add feature names to `feature_counts` (this is not handled already) and convert to a data frame.

```{r save-image, echo=FALSE, cache=FALSE}
save(file="feature-counts.RData", tRF_expression, feature_counts, features, prad_metadata)
save(file="features.RData", features)
save.image('feature-counts-image.RData')
```

